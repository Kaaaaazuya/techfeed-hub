import * as cdk from 'aws-cdk-lib';
import { Template } from 'aws-cdk-lib/assertions';
import { TestTechfeedStack } from '../lib/test-stack';

describe('TechfeedStack', () => {
  let app: cdk.App;
  let stack: TestTechfeedStack;
  let template: Template;

  beforeEach(() => {
    app = new cdk.App();
    stack = new TestTechfeedStack(app, 'TestTechfeedStack');
    template = Template.fromStack(stack);
  });

  describe('VPC Configuration', () => {
    test('should create VPC with correct configuration', () => {
      template.hasResourceProperties('AWS::EC2::VPC', {
        CidrBlock: '10.0.0.0/16',
        EnableDnsHostnames: true,
        EnableDnsSupport: true,
      });
    });

    test('should create public and private subnets', () => {
      template.resourceCountIs('AWS::EC2::Subnet', 4); // 2 AZs Ã— 2 subnet types
      
      // Public subnets
      template.hasResourceProperties('AWS::EC2::Subnet', {
        MapPublicIpOnLaunch: true,
      });

      // Private subnets (isolated)
      template.hasResourceProperties('AWS::EC2::Subnet', {
        MapPublicIpOnLaunch: false,
      });
    });

    test('should create Internet Gateway but no NAT Gateway', () => {
      template.resourceCountIs('AWS::EC2::InternetGateway', 1);
      template.resourceCountIs('AWS::EC2::NatGateway', 0);
    });
  });

  describe('Security Groups', () => {
    test('should create database and app security groups', () => {
      template.resourceCountIs('AWS::EC2::SecurityGroup', 4); // DB, App, ALB, ECS Service (Lambda shares App SG)
    });

    test('should configure database security group rules', () => {
      template.hasResourceProperties('AWS::EC2::SecurityGroupIngress', {
        IpProtocol: 'tcp',
        FromPort: 5432,
        ToPort: 5432,
      });

      template.hasResourceProperties('AWS::EC2::SecurityGroupIngress', {
        IpProtocol: 'tcp',
        FromPort: 6379,
        ToPort: 6379,
      });
    });
  });

  describe('RDS Database', () => {
    test('should create RDS PostgreSQL instance', () => {
      template.hasResourceProperties('AWS::RDS::DBInstance', {
        Engine: 'postgres',
        EngineVersion: '15.7',
        DBInstanceClass: 'db.t3.micro',
        AllocatedStorage: '20',
        StorageType: 'gp2',
        MultiAZ: false,
        DeletionProtection: false,
        DBName: 'techfeed_hub',
      });
    });

    test('should create DB secrets manager secret', () => {
      template.hasResourceProperties('AWS::SecretsManager::Secret', {
        Description: {
          'Fn::Join': [
            '',
            [
              'Generated by the CDK for stack: ',
              { Ref: 'AWS::StackName' },
            ],
          ],
        },
        GenerateSecretString: {
          SecretStringTemplate: '{"username":"techfeed_user"}',
          GenerateStringKey: 'password',
          PasswordLength: 30,
          ExcludeCharacters: ' %+~`#$&*()|[]{}:;<>?!\'/@"\\',
        },
      });
    });

    test('should configure backup retention', () => {
      template.hasResourceProperties('AWS::RDS::DBInstance', {
        BackupRetentionPeriod: 7,
        DeleteAutomatedBackups: true,
      });
    });
  });

  describe('ElastiCache Redis', () => {
    test('should create Redis subnet group', () => {
      template.hasResourceProperties('AWS::ElastiCache::SubnetGroup', {
        Description: 'Subnet group for Redis cluster',
      });
    });

    test('should create Redis cluster', () => {
      template.hasResourceProperties('AWS::ElastiCache::CacheCluster', {
        CacheNodeType: 'cache.t3.micro',
        Engine: 'redis',
        NumCacheNodes: 1,
      });
    });
  });

  describe('ECR Repositories', () => {
    test('should create API ECR repository', () => {
      template.hasResourceProperties('AWS::ECR::Repository', {
        RepositoryName: 'techfeed-api',
      });
    });

    test('should create RSS fetcher ECR repository', () => {
      template.hasResourceProperties('AWS::ECR::Repository', {
        RepositoryName: 'techfeed-rss-fetcher',
      });
    });

    test('should create two ECR repositories', () => {
      template.resourceCountIs('AWS::ECR::Repository', 2);
    });
  });

  describe('ECS Configuration', () => {
    test('should create ECS cluster', () => {
      template.hasResourceProperties('AWS::ECS::Cluster', {
        ClusterName: 'techfeed-cluster',
      });
    });

    test('should create Fargate service with correct configuration', () => {
      template.hasResourceProperties('AWS::ECS::Service', {
        DesiredCount: 1,
        PlatformVersion: 'LATEST',
      });
    });

    test('should create task definition with correct resources', () => {
      template.hasResourceProperties('AWS::ECS::TaskDefinition', {
        RequiresCompatibilities: ['FARGATE'],
        Cpu: '256',
        Memory: '512',
        NetworkMode: 'awsvpc',
      });
    });

    test('should configure container with environment variables', () => {
      const taskDef = template.findResources('AWS::ECS::TaskDefinition');
      const taskDefKey = Object.keys(taskDef)[0];
      const task = taskDef[taskDefKey];
      
      expect(task.Properties.ContainerDefinitions).toHaveLength(1);
      expect(task.Properties.ContainerDefinitions[0].Environment).toEqual(
        expect.arrayContaining([
          { Name: 'DB_HOST', Value: expect.any(Object) },
          { Name: 'DB_PORT', Value: '5432' },
          { Name: 'DB_NAME', Value: 'techfeed_hub' },
          { Name: 'REDIS_HOST', Value: expect.any(Object) },
          { Name: 'REDIS_PORT', Value: '6379' },
        ])
      );
    });

    test('should use Fargate Spot capacity provider', () => {
      template.hasResourceProperties('AWS::ECS::Service', {
        CapacityProviderStrategy: [
          {
            CapacityProvider: 'FARGATE_SPOT',
            Weight: 1,
          },
        ],
      });
    });
  });

  describe('Application Load Balancer', () => {
    test('should create ALB', () => {
      template.resourceCountIs('AWS::ElasticLoadBalancingV2::LoadBalancer', 1);
      template.hasResourceProperties('AWS::ElasticLoadBalancingV2::LoadBalancer', {
        Scheme: 'internet-facing',
        Type: 'application',
      });
    });

    test('should create target group', () => {
      template.hasResourceProperties('AWS::ElasticLoadBalancingV2::TargetGroup', {
        Port: 80,
        Protocol: 'HTTP',
        TargetType: 'ip',
      });
    });
  });

  describe('S3 Frontend Bucket', () => {
    test('should create S3 bucket with website configuration', () => {
      template.hasResourceProperties('AWS::S3::Bucket', {
        WebsiteConfiguration: {
          IndexDocument: 'index.html',
          ErrorDocument: '404.html',
        },
        PublicAccessBlockConfiguration: {
          BlockPublicAcls: true,
          IgnorePublicAcls: true,
        },
      });
    });

    test('should create bucket policy for public read access', () => {
      template.hasResourceProperties('AWS::S3::BucketPolicy', {
        PolicyDocument: {
          Statement: [
            {
              Effect: 'Allow',
              Principal: {
                AWS: '*',
              },
              Action: 's3:GetObject',
            },
          ],
        },
      });
    });
  });

  describe('CloudFront Distribution', () => {
    test('should create CloudFront distribution', () => {
      template.hasResourceProperties('AWS::CloudFront::Distribution', {
        DistributionConfig: {
          DefaultRootObject: 'index.html',
          CustomErrorResponses: [
            {
              ErrorCode: 404,
              ResponseCode: 200,
              ResponsePagePath: '/index.html',
            },
          ],
        },
      });
    });

    test('should configure HTTPS redirect', () => {
      template.hasResourceProperties('AWS::CloudFront::Distribution', {
        DistributionConfig: {
          DefaultCacheBehavior: {
            ViewerProtocolPolicy: 'redirect-to-https',
          },
        },
      });
    });
  });


  describe('IAM Permissions', () => {
    test('should grant ECS task access to secrets', () => {
      const policies = template.findResources('AWS::IAM::Policy');
      const hasSecretsAccess = Object.values(policies).some((policy: any) => {
        const statements = policy.Properties?.PolicyDocument?.Statement || [];
        return statements.some((stmt: any) => 
          stmt.Action?.includes('secretsmanager:GetSecretValue')
        );
      });
      expect(hasSecretsAccess).toBe(true);
    });

    test('should grant Lambda access to secrets', () => {
      const roles = template.findResources('AWS::IAM::Role');
      const lambdaRoles = Object.values(roles).filter((role: any) => 
        role.Properties?.AssumeRolePolicyDocument?.Statement?.some((stmt: any) =>
          stmt.Principal?.Service?.includes('lambda.amazonaws.com')
        )
      );
      expect(lambdaRoles.length).toBeGreaterThan(0);
    });

    test('should create Lambda execution role with VPC permissions', () => {
      const roles = template.findResources('AWS::IAM::Role');
      const lambdaRole = Object.values(roles).find((role: any) => 
        role.Properties?.AssumeRolePolicyDocument?.Statement?.some((stmt: any) =>
          stmt.Principal?.Service === 'lambda.amazonaws.com'
        )
      ) as any;
      
      expect(lambdaRole).toBeDefined();
      expect(lambdaRole.Properties.ManagedPolicyArns).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            'Fn::Join': expect.arrayContaining([
              '',
              expect.arrayContaining([
                'arn:',
                { Ref: 'AWS::Partition' },
                ':iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole',
              ])
            ])
          })
        ])
      );
    });
  });

  describe('Lambda Function', () => {
    test('should create Lambda function for RSS fetching', () => {
      template.hasResourceProperties('AWS::Lambda::Function', {
        PackageType: 'Image',
        Timeout: 900, // 15 minutes
        MemorySize: 1024,
      });
    });

    test('should configure Lambda environment variables', () => {
      const lambdaFunctions = template.findResources('AWS::Lambda::Function');
      const lambdaKey = Object.keys(lambdaFunctions)[0];
      const lambda = lambdaFunctions[lambdaKey];
      
      expect(lambda.Properties.Environment.Variables).toEqual(
        expect.objectContaining({
          DB_HOST: expect.any(Object),
          DB_PORT: '5432',
          DB_NAME: 'techfeed_hub',
          REDIS_HOST: expect.any(Object),
          REDIS_PORT: '6379',
          DB_SECRET_ARN: expect.any(Object),
        })
      );
    });

    test('should place Lambda in VPC', () => {
      const lambdaFunctions = template.findResources('AWS::Lambda::Function');
      const lambdaFunction = Object.values(lambdaFunctions)[0] as any;
      
      expect(lambdaFunction.Properties.VpcConfig).toBeDefined();
      expect(lambdaFunction.Properties.VpcConfig.SubnetIds).toEqual(expect.any(Array));
      expect(lambdaFunction.Properties.VpcConfig.SecurityGroupIds).toEqual(expect.any(Array));
    });
  });

  describe('EventBridge', () => {
    test('should create EventBridge rule for RSS fetching schedule', () => {
      template.hasResourceProperties('AWS::Events::Rule', {
        ScheduleExpression: 'cron(0 */3 * * ? *)',
        State: 'ENABLED',
      });
    });

    test('should configure Lambda as EventBridge target', () => {
      const rules = template.findResources('AWS::Events::Rule');
      const rule = Object.values(rules)[0] as any;
      
      expect(rule.Properties.Targets).toBeDefined();
      expect(rule.Properties.Targets).toHaveLength(1);
      expect(rule.Properties.Targets[0]).toEqual(
        expect.objectContaining({
          Arn: expect.any(Object),
          Id: expect.any(String),
        })
      );
    });
  });

  describe('Stack Outputs', () => {
    test('should create all required outputs', () => {
      const outputs = template.findOutputs('*');
      
      expect(outputs).toHaveProperty('DatabaseEndpoint');
      expect(outputs).toHaveProperty('RedisEndpoint'); 
      expect(outputs).toHaveProperty('ApiLoadBalancerUrl');
      expect(outputs).toHaveProperty('FrontendUrl');
      expect(outputs).toHaveProperty('EcrApiRepositoryUri');
      expect(outputs).toHaveProperty('EcrRssRepositoryUri');
      expect(outputs).toHaveProperty('RssLambdaFunctionName');
    });
  });

  describe('Cost Optimization', () => {
    test('should use cost-optimized instance types', () => {
      // RDS
      template.hasResourceProperties('AWS::RDS::DBInstance', {
        DBInstanceClass: 'db.t3.micro',
      });

      // Redis
      template.hasResourceProperties('AWS::ElastiCache::CacheCluster', {
        CacheNodeType: 'cache.t3.micro',
      });

      // ECS
      template.hasResourceProperties('AWS::ECS::TaskDefinition', {
        Cpu: '256',
        Memory: '512',
      });
    });

    test('should disable multi-AZ for cost savings', () => {
      template.hasResourceProperties('AWS::RDS::DBInstance', {
        MultiAZ: false,
      });
    });

    test('should use single cache node', () => {
      template.hasResourceProperties('AWS::ElastiCache::CacheCluster', {
        NumCacheNodes: 1,
      });
    });
  });
});
